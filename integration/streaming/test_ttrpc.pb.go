// Code generated by protoc-gen-go-ttrpc. DO NOT EDIT.
// source: github.com/containerd/ttrpc/integration/streaming/test.proto
package streaming

import (
	context "context"
	ttrpc "github.com/containerd/ttrpc"
	empty "github.com/golang/protobuf/ptypes/empty"
)

type StreamingService interface {
	Echo(context.Context, *EchoPayload) (*EchoPayload, error)
	EchoStream(context.Context, Streaming_EchoStreamServer) error
	SumStream(context.Context, Streaming_SumStreamServer) (*Sum, error)
	DivideStream(context.Context, *Sum, Streaming_DivideStreamServer) error
	EchoNull(context.Context, Streaming_EchoNullServer) (*empty.Empty, error)
	EchoNullStream(context.Context, Streaming_EchoNullStreamServer) error
}

type Streaming_EchoStreamServer interface {
	Send(*EchoPayload) error
	Recv() (*EchoPayload, error)
	ttrpc.StreamServer
}

type streamingEchoStreamServer struct {
	ttrpc.StreamServer
}

func (x *streamingEchoStreamServer) Send(m *EchoPayload) error {
	return x.StreamServer.SendMsg(m)
}

func (x *streamingEchoStreamServer) Recv() (*EchoPayload, error) {
	m := new(EchoPayload)
	if err := x.StreamServer.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type Streaming_SumStreamServer interface {
	Recv() (*Part, error)
	ttrpc.StreamServer
}

type streamingSumStreamServer struct {
	ttrpc.StreamServer
}

func (x *streamingSumStreamServer) Recv() (*Part, error) {
	m := new(Part)
	if err := x.StreamServer.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type Streaming_DivideStreamServer interface {
	Send(*Part) error
	ttrpc.StreamServer
}

type streamingDivideStreamServer struct {
	ttrpc.StreamServer
}

func (x *streamingDivideStreamServer) Send(m *Part) error {
	return x.StreamServer.SendMsg(m)
}

type Streaming_EchoNullServer interface {
	Recv() (*EchoPayload, error)
	ttrpc.StreamServer
}

type streamingEchoNullServer struct {
	ttrpc.StreamServer
}

func (x *streamingEchoNullServer) Recv() (*EchoPayload, error) {
	m := new(EchoPayload)
	if err := x.StreamServer.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type Streaming_EchoNullStreamServer interface {
	Send(*empty.Empty) error
	Recv() (*EchoPayload, error)
	ttrpc.StreamServer
}

type streamingEchoNullStreamServer struct {
	ttrpc.StreamServer
}

func (x *streamingEchoNullStreamServer) Send(m *empty.Empty) error {
	return x.StreamServer.SendMsg(m)
}

func (x *streamingEchoNullStreamServer) Recv() (*EchoPayload, error) {
	m := new(EchoPayload)
	if err := x.StreamServer.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func RegisterStreamingService(srv *ttrpc.Server, svc StreamingService) {
	srv.RegisterService("ttrpc.integration.streaming.Streaming", &ttrpc.ServiceDesc{
		Methods: map[string]ttrpc.Method{
			"Echo": func(ctx context.Context, unmarshal func(interface{}) error) (interface{}, error) {
				var req EchoPayload
				if err := unmarshal(&req); err != nil {
					return nil, err
				}
				return svc.Echo(ctx, &req)
			},
		},
		Streams: map[string]ttrpc.Stream{
			"EchoStream": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					return nil, svc.EchoStream(ctx, &streamingEchoStreamServer{stream})
				},
				StreamingClient: true,
				StreamingServer: true,
			},
			"SumStream": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					return svc.SumStream(ctx, &streamingSumStreamServer{stream})
				},
				StreamingClient: true,
				StreamingServer: false,
			},
			"DivideStream": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					m := new(Sum)
					if err := stream.RecvMsg(m); err != nil {
						return nil, err
					}
					return nil, svc.DivideStream(ctx, m, &streamingDivideStreamServer{stream})
				},
				StreamingClient: false,
				StreamingServer: true,
			},
			"EchoNull": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					return svc.EchoNull(ctx, &streamingEchoNullServer{stream})
				},
				StreamingClient: true,
				StreamingServer: false,
			},
			"EchoNullStream": {
				Handler: func(ctx context.Context, stream ttrpc.StreamServer) (interface{}, error) {
					return nil, svc.EchoNullStream(ctx, &streamingEchoNullStreamServer{stream})
				},
				StreamingClient: true,
				StreamingServer: true,
			},
		},
	})
}

type StreamingClient interface {
	Echo(context.Context, *EchoPayload) (*EchoPayload, error)
	EchoStream(context.Context) (Streaming_EchoStreamClient, error)
	SumStream(context.Context) (Streaming_SumStreamClient, error)
	DivideStream(context.Context, *Sum) (Streaming_DivideStreamClient, error)
	EchoNull(context.Context) (Streaming_EchoNullClient, error)
	EchoNullStream(context.Context) (Streaming_EchoNullStreamClient, error)
}

type streamingClient struct {
	client *ttrpc.Client
}

func NewStreamingClient(client *ttrpc.Client) StreamingClient {
	return &streamingClient{
		client: client,
	}
}

func (c *streamingClient) Echo(ctx context.Context, req *EchoPayload) (*EchoPayload, error) {
	var resp EchoPayload
	if err := c.client.Call(ctx, "ttrpc.integration.streaming.Streaming", "Echo", req, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

func (c *streamingClient) EchoStream(ctx context.Context) (Streaming_EchoStreamClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: true,
		StreamingServer: true,
	}, "ttrpc.integration.streaming.Streaming", "EchoStream", nil)
	if err != nil {
		return nil, err
	}
	x := &streamingEchoStreamClient{stream}
	return x, nil
}

type Streaming_EchoStreamClient interface {
	Send(*EchoPayload) error
	Recv() (*EchoPayload, error)
	ttrpc.ClientStream
}

type streamingEchoStreamClient struct {
	ttrpc.ClientStream
}

func (x *streamingEchoStreamClient) Send(m *EchoPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamingEchoStreamClient) Recv() (*EchoPayload, error) {
	m := new(EchoPayload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingClient) SumStream(ctx context.Context) (Streaming_SumStreamClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: true,
		StreamingServer: false,
	}, "ttrpc.integration.streaming.Streaming", "SumStream", nil)
	if err != nil {
		return nil, err
	}
	x := &streamingSumStreamClient{stream}
	return x, nil
}

type Streaming_SumStreamClient interface {
	Send(*Part) error
	CloseAndRecv() (*Sum, error)
	ttrpc.ClientStream
}

type streamingSumStreamClient struct {
	ttrpc.ClientStream
}

func (x *streamingSumStreamClient) Send(m *Part) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamingSumStreamClient) CloseAndRecv() (*Sum, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Sum)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingClient) DivideStream(ctx context.Context, req *Sum) (Streaming_DivideStreamClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: false,
		StreamingServer: true,
	}, "ttrpc.integration.streaming.Streaming", "DivideStream", req)
	if err != nil {
		return nil, err
	}
	x := &streamingDivideStreamClient{stream}
	return x, nil
}

type Streaming_DivideStreamClient interface {
	Recv() (*Part, error)
	ttrpc.ClientStream
}

type streamingDivideStreamClient struct {
	ttrpc.ClientStream
}

func (x *streamingDivideStreamClient) Recv() (*Part, error) {
	m := new(Part)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingClient) EchoNull(ctx context.Context) (Streaming_EchoNullClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: true,
		StreamingServer: false,
	}, "ttrpc.integration.streaming.Streaming", "EchoNull", nil)
	if err != nil {
		return nil, err
	}
	x := &streamingEchoNullClient{stream}
	return x, nil
}

type Streaming_EchoNullClient interface {
	Send(*EchoPayload) error
	CloseAndRecv() (*empty.Empty, error)
	ttrpc.ClientStream
}

type streamingEchoNullClient struct {
	ttrpc.ClientStream
}

func (x *streamingEchoNullClient) Send(m *EchoPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamingEchoNullClient) CloseAndRecv() (*empty.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamingClient) EchoNullStream(ctx context.Context) (Streaming_EchoNullStreamClient, error) {
	stream, err := c.client.NewStream(ctx, &ttrpc.StreamDesc{
		StreamingClient: true,
		StreamingServer: true,
	}, "ttrpc.integration.streaming.Streaming", "EchoNullStream", nil)
	if err != nil {
		return nil, err
	}
	x := &streamingEchoNullStreamClient{stream}
	return x, nil
}

type Streaming_EchoNullStreamClient interface {
	Send(*EchoPayload) error
	Recv() (*empty.Empty, error)
	ttrpc.ClientStream
}

type streamingEchoNullStreamClient struct {
	ttrpc.ClientStream
}

func (x *streamingEchoNullStreamClient) Send(m *EchoPayload) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamingEchoNullStreamClient) Recv() (*empty.Empty, error) {
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}
